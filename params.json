{"name":"Tornado-mongodb-example-app","tagline":"simple example webserver using tornado-mongodb using nginx and supervisor.","body":"Tornado and MongoDB needs no introduction. Here I am going to explain how to host an app/api with Tornado+MongoDB using nginx server as a proxy/load balancing and supervisor for process management.\r\n\r\nThis simple configuration can be done with few hours to up and run the site/api. \r\n\r\nFirst let us see the Tornado simple code.\r\n\r\n#####Template and Static file paths:\r\n\r\nTornado has option to define, templates and statics file paths. For static paths, ensure that, you're calling */static/* followed by file name. ie /static/static file (eg http://localhost/static/jquery.js). This can be changed using **static_url_prefix** option in the settings.\r\n\r\nexample code:\r\n~~~python\r\ntemplate_path = os.path.join( '/home/test/website/', \"templates\" ),\r\nstatic_path = os.path.join( '/home/test/website/', 'assets' )\r\n~~~\r\n\r\nor simply,\r\n\r\n~~~python\r\ntemplate_path = '/home/test/website/templates',\r\nstatic_path = '/home/test/website/assets'\r\n~~~\r\n\r\n#####Defining port/db settings\r\nPassing the command line can be defined using \"options\" or can be parsed using parse_command_line option.\r\n~~~python\r\ndefine( \"port\", default = 8888, type = int )\r\nparse_command_line()\r\n~~~\r\n\r\n#####Defining handlers for different paths\r\nIt is easy to map which url path should be served by which function. adding that in handlers takes care of that. It is also possible to map based on regular expressions too.\r\n\r\n~~~python\r\nhandlers = [( r\"/\", HomeHandler ),\r\n            ( r\"/api\", MyAPIHandler ),\r\n            ( r\"/demo\", DemoUI )\r\n            ]\r\n~~~\r\n\r\nfunctions\r\n\r\n~~~python\r\nclass DemoUI( BaseHandler )\r\n    def get( self ):\r\n\t\tnumber= [i for i in range(0,10) ]\r\n    \tself.render( \"one.html\" , title = \"one\",numberlist=number )\r\nclass HomeHandler( BaseHandler ):\r\n    def get( self ):\r\n        self.render( \"index.html\" )\r\n~~~\r\n\r\n** render** renders the templete with the variables.\r\n\r\n#####rendering data in html templete\r\n\r\nTo pass the value to html templete and render it, pass the value to the variable defined in the templete.\r\n\r\n~~~html\r\n<html>\r\n   <head>\r\n      <title>{{ title }}</title>\r\n   </head>\r\n   <body>\r\n   \t<div>\r\n    \t<table>\r\n         {% for number in numberlist %}\r\n         <tr>\r\n            <td>{{ number }}</td>\r\n         </tr>\r\n         {% end %}\r\n         </table>\r\n        </div>\r\n    </div>\r\n   </body>\r\n</html>\r\n~~~\r\n#####Setting multiple inheritance\r\nMultiple inheritance useful for things such as db connections etc. DB connections can be resued using this.\r\n\r\n~~~python\r\nsuper( Example, self ).__init__( handlers, **settings )\r\n~~~\r\n\r\n#####BaseHandler for property definition\r\nonce the property is defined in the basehandler, it will be availble to all the handlers. In the example, property for using db connection is defined.\r\n\r\ncreate connection in the __init__ function\r\n\r\n~~~python\r\nsession = MongoClient()\r\nself.firstCol = session.firstDB.firstCol\r\nself.secondCol = session.secondDB.secondCol\r\n~~~\r\n\r\ndefine the property in a **basehandler** calss\r\n\r\n~~~python\r\nclass BaseHandler( tornado.web.RequestHandler ):\r\n    @property\r\n    def secondCol( self ):\r\n        return self.application.secondCol\r\n    @property\r\n    def firstCol( self ):\r\n        return self.application.firstCol\r\n~~~\r\n\r\nNow, calling **self.firstcol** from any function refers to the connections\r\n\r\n#####Logging\r\ntornado enables default logging into access,error,general loggers. This can be turned off using --logging=none option when starting the server. It is also easy to send the log to different file. But issue come when you try to turn off default logging and log only needed.  For the default logger should be propageted  false. In the example only access log is turned off. Also rotating file handler for logger using to roate the log files if maximum size is reached. \r\n\r\n~~~python\r\noptions.logging = None\r\naccess = logging.NullHandler()\r\naccess.setLevel( logging.DEBUG )\r\nlogging.getLogger( \"tornado.access\" ).addHandler( access )\r\nlogging.getLogger( \"tornado.access\" ).propagate = False\r\nLOG_FILENAME = '/home/test/logging.log'\r\nhandler = logging.handlers.RotatingFileHandler( LOG_FILENAME, maxBytes = 1 * 1024 * 1024, backupCount = 10 )\r\nformatter = logging.Formatter(\r\n        '%(asctime)s process [%(process)d]: %(message)s',\r\n        '%b %d %H:%M:%S' )\r\nhandler.setFormatter( formatter )\r\nlogger = logging.getLogger()\r\nlogger.addHandler( handler )\r\nlogger.setLevel( logging.DEBUG )\r\n~~~\r\n\r\n#####using xsrf cookie to make app secure\r\n\r\nit is easy to restrict access to the app only via browser thus restricting crawling options. add xsrf_cookies = True, to the settings and add this to the html form\r\n\r\n~~~html\r\n{ % module xsrf_form_html() % }\r\n\r\n~~~\r\n\r\nwhen loading the form, xsrf cooking will be rendered as hidden parameter.\r\n\r\nif there is a need to disable xsrf for only one handler and enable for others, add this to the handler function. This will remove the check for that handler only.\r\n\r\n~~~python\r\n   def check_xsrf_cookie( self ):\r\n        pass\r\n~~~\r\n\r\n###Confiuring nginx\r\nTornado is an web server itself, so why we need [Nginx](http://nginx.org) as a additional component?\r\n\r\nnginx is used as a proxy server and load balancer. nginx sits between the server and client, distributes the traffic and offers additional things as rate limiting etc.\r\n\r\nLoad Balancing with nginx is easy. Let us say, you have four process running in a single machine and you want each process to handle the requests from users simultaneously you can configure that in nginx conf.\r\n\r\nEach process running separate port will be connected to ngnix sever and nginxâ€™s single port shown to the user.\r\n\r\ndefining app ip settings\r\n\r\n~~~conf\r\nupstream myapp\r\n\t{\r\n\t    server 127.0.0.1:8888;\r\n\t    server 127.0.0.1:8889;\r\n\t    server 127.0.0.1:8890;\r\n\t    server 127.0.0.1:8891;\r\n\t}\r\n~~~\r\n\r\nhere, one server is going to listen all the four ips. Defining various ips using various ports is also available.\r\n\r\nNext defining server option\r\n\r\n~~~conf\r\n   server\r\n\t{\r\n\t  listen 127.0.0.1:80;\r\n\r\n\t  location /\r\n\t  {\r\n\t    proxy_pass http://myapp;\r\n\t    proxy_set_header X-Real-IP $remote_addr;\r\n\t    limit_req zone=index burst=1;\r\n\t  }\r\n\r\n\t  location /api/\r\n\t  {\r\n\t    proxy_pass http://myapp;\r\n\t    proxy_set_header X-Real-IP $remote_addr;\r\n\t    limit_req zone=api burst=10 nodelay;\r\n\t  }\r\n\r\n\t}\r\n~~~\r\n\r\nlisten is self explonatory. It exposes nginx running port to public.\r\n\r\n** proxy_pass** takes care of the load balancing between requests. Without that load wont be distributed.\r\n\r\n** proxy_set_header** would set the actual ip of the request in the request headers. Which means, requests has the actual ip from which the app is accessed. If the app is exposed to public, the actual ip from which customers accessing would be forwared to tornado process.\r\n\r\n** limit_req zone** option defines the number of requests the server can handle per second or mintue. that is defined in this line\r\n~~~conf\r\nlimit_req_zone $binary_remote_addr zone=api:1m  rate=100r/s;\r\n~~~\r\n** burst** allows how many requests can be handled at a time and nodelay configures if the requests should be put into the queue or not.\r\n\r\nif rate is 100r/s and burst is 10 with nodelay, then 10 requests would be processed in batches.\r\n\r\n#####Using Supervisor\r\nHandling start/shutdown of the processes can be handled using [Supervisor](http://supervisord.org)\r\n\r\nlet us say, four processes needs to be started for tornado,\r\nuse this supervisor configuration to start those processes\r\n\r\n~~~conf\r\n[program:firstapp]\r\nprocess_name=firstapp%(process_num)s\r\ndirectory=/home/test/\r\ncommand=python /home/test/tornado_example.py --port=%(process_num)s --logging=debug\r\nstdout_logfile=/home/test/out-%(process_num)s.log\r\nstderr_logfile=/home/test/err-%(process_num)s.log\r\nstartsecs=2\r\nnumprocs=4\r\nnumprocs_start=8888\r\n~~~\r\n\r\nSupervisor can restart the processes if there is an expection or system reboot.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}