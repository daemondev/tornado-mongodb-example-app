{"name":"Tornado-mongodb-example-app","tagline":"simple example webserver using tornado-mongodb using nginx and supervisor.","body":"Tornado and MongoDB needs no introduction. Here I am going to explain how to host an app/API with Tornado+MongoDB using Nginx server as a proxy/load balancing and supervisor for process management.\r\n\r\nThis simple configuration can be done with few hours to up and run the site/API. This configuration runs my site [NaturalText](http://naturaltext.com). \r\n\r\nFirst let us see the Tornado sample code.\r\n\r\n####Template and Static file paths:\r\n\r\nTornado has options to define, templates and statics file paths. For static paths, ensure that, you're calling */static/* followed by file name. ie /static/static file (eg http://localhost/static/jquery.js). This can be changed using **static_url_prefix** option in the settings.\r\n\r\nexample code:\r\n~~~python\r\ntemplate_path = os.path.join( '/home/test/website/', \"templates\" ),\r\nstatic_path = os.path.join( '/home/test/website/', 'assets' )\r\n~~~\r\n\r\nor simply,\r\n\r\n~~~python\r\ntemplate_path = '/home/test/website/templates',\r\nstatic_path = '/home/test/website/assets'\r\n~~~\r\n\r\n####Defining port/db settings\r\nPassing the command line defined using \"options\" or parsed command line arguments using parse_command_line option.\r\n~~~python\r\ndefine( \"port\", default = 8888, type = int )\r\nparse_command_line()\r\n~~~\r\n\r\n####Defining handlers for different paths\r\nFor mapping which URL path should be served by which function handled by adding handlers. It supports map based on regular expressions too.\r\n\r\n~~~python\r\nhandlers = [( r\"/\", HomeHandler ),\r\n            ( r\"/api\", MyAPIHandler ),\r\n            ( r\"/demo\", DemoUI )\r\n            ]\r\n~~~\r\n\r\nfunctions\r\n\r\n~~~python\r\nclass DemoUI( BaseHandler )\r\n    def get( self ):\r\n\t\tnumber= [i for i in range(0,10) ]\r\n    \tself.render( \"one.html\" , title = \"one\",numberlist=number )\r\nclass HomeHandler( BaseHandler ):\r\n    def get( self ):\r\n        self.render( \"index.html\" )\r\n~~~\r\n\r\n**render** renders the *HTML template* with the variables.\r\n\r\n####Rendering data in HTML template\r\n\r\nTo show the data in HTML template, pass the data to the variable defined in the template using *render* function.\r\n\r\n**numberlist** is defined in the template, so *render* functions should pass the date to *numberlist* variable.\r\n\r\n~~~html\r\n<html>\r\n   <head>\r\n      <title>{{ title }}</title>\r\n   </head>\r\n   <body>\r\n   \t<div>\r\n    \t<table>\r\n         {% for number in numberlist %}\r\n         <tr>\r\n            <td>{{ number }}</td>\r\n         </tr>\r\n         {% end %}\r\n         </table>\r\n        </div>\r\n    </div>\r\n   </body>\r\n</html>\r\n~~~\r\n####Setting multiple inheritance\r\nMultiple inheritance useful for things such as reusing db connections etc.\r\n\r\n~~~python\r\nsuper( Example, self ).__init__( handlers, **settings )\r\n~~~\r\n\r\n####BaseHandler for property definition\r\nOnce the property is defined in the basehandler, it will be available to all the handlers. In the example, property for connecting db is defined.\r\n\r\ncreate connection in the __init__ function\r\n\r\n~~~python\r\nsession = MongoClient()\r\nself.firstCol = session.firstDB.firstCol\r\nself.secondCol = session.secondDB.secondCol\r\n~~~\r\n\r\ndefine the property in a **basehandler** class\r\n\r\n~~~python\r\nclass BaseHandler( tornado.web.RequestHandler ):\r\n    @property\r\n    def secondCol( self ):\r\n        return self.application.secondCol\r\n    @property\r\n    def firstCol( self ):\r\n        return self.application.firstCol\r\n~~~\r\n\r\nNow, calling **self.firstcol** from any function refers to the db connection. \r\n\r\n####Logging\r\nTornado enables default logging for access,error and general loggers. This can be turned off using **--logging=none** option when starting the server. Logging to separate output file is done using python loggers. However, to turn off default logging and log only needed(custom logging), default logger should be propagated to false, else all logs would be logged too. In the example, only access log is turned off. \r\n\r\n~~~python\r\noptions.logging = None\r\naccess = logging.NullHandler()\r\naccess.setLevel( logging.DEBUG )\r\nlogging.getLogger( \"tornado.access\" ).addHandler( access )\r\nlogging.getLogger( \"tornado.access\" ).propagate = False #turn off access log\r\nLOG_FILENAME = '/home/test/logging.log'\r\nhandler = logging.handlers.RotatingFileHandler( LOG_FILENAME, maxBytes = 1 * 1024 * 1024, backupCount = 10 )\r\nformatter = logging.Formatter(\r\n        '%(asctime)s process [%(process)d]: %(message)s',\r\n        '%b %d %H:%M:%S' )\r\nhandler.setFormatter( formatter )\r\nlogger = logging.getLogger()\r\nlogger.addHandler( handler )\r\nlogger.setLevel( logging.DEBUG )\r\n~~~\r\n\r\n####Using xsrf cookie to make app secure\r\n\r\nRestricting the access of the app to browser for disabling automatic crawling is simple in Tornado. Add \r\n\r\n~~~python\r\nxsrf_cookies = True\r\n~~~\r\n\r\nto the settings and add below code to HTML POST form\r\n\r\n~~~html\r\n{ % module xsrf_form_html() % }\r\n\r\n~~~\r\n\r\nWhen loading the HTML form, *xsrf cookie* will be rendered as hidden parameter. Tornado automatically checks the cookie. \r\n\r\n*xsrf cookie* check can skipped for one particular handler. \r\n\r\n~~~python\r\n   def check_xsrf_cookie( self ):\r\n        pass\r\n~~~\r\n\r\nAdding this code, disables *xsrf cookie* check for that particular handler only. \r\n\r\n###Configuring Nginx\r\nTornado is an web server itself, so why [Nginx](http://nginx.org) needed?\r\n\r\nNginx is used as a proxy server and load balancer. Nginx sits between the server and client, distributes the traffic and offers additional controls as rate limiting etc.\r\n\r\nLoad Balancing with Nginx is easy. Let us say, four process running in a single machine and each process to handle the requests from users simultaneously, can be configured in Nginx conf.\r\n\r\nEach process running in separate port will be connected to Nginx sever and Nginx's port shown to the user.\r\n\r\n####Defining app IP settings\r\n\r\n~~~conf\r\nupstream myapp\r\n\t{\r\n\t    server 127.0.0.1:8888;\r\n\t    server 127.0.0.1:8889;\r\n\t    server 127.0.0.1:8890;\r\n\t    server 127.0.0.1:8891;\r\n\t}\r\n~~~\r\n\r\nhere, one server is going to listen all the four IPs. Defining various IPs using various ports is also available.\r\n\r\n####Defining server option\r\n\r\n~~~conf\r\n   server\r\n\t{\r\n\t  listen 127.0.0.1:80;\r\n\r\n\t  location /\r\n\t  {\r\n\t    proxy_pass http://myapp;\r\n\t    proxy_set_header X-Real-IP $remote_addr;\r\n\t    limit_req zone=index burst=1;\r\n\t  }\r\n\r\n\t  location /api/\r\n\t  {\r\n\t    proxy_pass http://myapp;\r\n\t    proxy_set_header X-Real-IP $remote_addr;\r\n\t    limit_req zone=api burst=10 nodelay;\r\n\t  }\r\n\r\n\t}\r\n~~~\r\n\r\n**listen** is self explanatory. It exposes Nginx's running port to public.\r\n\r\n**proxy_pass** takes care of the load balancing between requests. Without that load wont be distributed.\r\n\r\n**proxy_set_header** sets the actual IP of the request in the request headers. Which means, requests has the actual IP from which, the app is accessed instead of Nginx server's IP. \r\n\r\n**limit_req zone** option defines the number of requests the server can handle per second or minute. \r\n\r\nFor example, \r\n\r\n~~~conf\r\nlimit_req_zone $binary_remote_addr zone=api:1m  rate=100r/s;\r\n~~~\r\n**burst** allows how many requests can be handled at a time and **nodelay** configures, if the requests should be put into the queue or not.\r\n\r\nif **rate** is 100r/s and **burst** is 10 with **nodelay**, then 10 requests would be processed in batches.\r\n\r\n###Using Supervisor\r\nHandling start/shutdown of the processes can be handled using [Supervisor](http://supervisord.org)\r\n\r\nlet us say, four processes needs to be started for tornado,\r\nuse this supervisor configuration to start those processes\r\n\r\n~~~conf\r\n[program:firstapp]\r\nprocess_name=firstapp%(process_num)s\r\ndirectory=/home/test/\r\ncommand=python /home/test/tornado_example.py --port=%(process_num)s --logging=debug\r\nstdout_logfile=/home/test/out-%(process_num)s.log\r\nstderr_logfile=/home/test/err-%(process_num)s.log\r\nstartsecs=2\r\nnumprocs=4\r\nnumprocs_start=8888\r\n~~~\r\n\r\nSupervisor restarts the processes if Tornado exits because of an exception or system reboot.\r\n\r\nFor comments, please connect [@rajasankar](http://twitter.com/rajasankar) , [Rajasankar](http://facebook.com/rajasankar)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}